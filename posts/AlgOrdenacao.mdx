---
    title: Principais algoritmos de ordenação e suas caracteristicas
    description  : Como funciona os algoritmos de ordenação e suas caracteristicas
    date: 24-12-2023
---

# Algoritmos de ordenação simples e suas caracteristicas

Aqui veremos como funcionam alguns algoritmos de ordenação simples e suas determinadas caracteristicas, 
a ordenação é uma operação fundamental na ciência da computação, e pode ser usada em uma grande variedade de aplicações para diminuir a complexidade de um problema.
Na vida real ordenação tambem é essencial para realizar pesquisas de maneira mais rapida e eficiente.

  
  
<br/><br/>
## **Primeiro de tudo o que são algoritmos exatamente?**
Um breve resumo do que são algoritmos é: eles são uma sequencia de passos que resolvem um determinado problema.
por exemplo uma receita de bolo onde você tem que seguir determinadas instruções para fazer o seu bolo.

  
<br/><br/>
## **O que são algoritmos de ordenação?**

Algoritmos de ordenação são instruções que rearranjam uma estrutura de dados em uma determinada ordem sejam elas crescentes ou decrescentes,
esses mesmos elementos podem ser números,letras ou qualquer outro tipo de dado.
Há varios metodos de ordenação, cada um com suas vantagens e desvantagens, e cada um é mais adequado para um tipo de situação.

<br/><br/>
## **Algoritmos de ordenação mais simples**

  
<br/>
### **1. Bubble Sort**

Esse algoritmo se resolve em torno de percorrer uma lista e comparar os valores adjacentes e troca-os caso não estiverem na ordem correta.

  
<br/><br/>
Passo a passo do algoritmo:

<br/>

1. Percorra a lista da esquerda para a direita ou vice-versa(Faremos o passo a passo da esquerda para a direita).

2. Compare cada elemento com o elemento adjacente à sua direita.

3. Se o elemento da esquerda for maior que o elemento da direita, troca-se de posição.

4. Repita-se os passos 1 a 3 até que a lista esteja ordenada.

  
<br/>
**Exemplo de código em C**

```c

  

void bubble_sort(int lista[], int TAM){

    for(int i = 0; i < TAM;i++){

        for(int j = 0; j < TAM - i - 1;j++){

            if(lista[j] > lista[j+1]){

                int temp = lista[j];

                lista[j] = lista[j+1];

                lista[j+1] = temp;

            }

        }

    }

}

```

<br/>  

### **2. Selection Sort**
<br/>
O Selection Sort se resume em um algoritmo que opera encontrando repetidamente o menor elemento da parte nao ordenada da lista
e trocando-o com o primeiro elemento não ordenado, esse processo é repetido até que a lista esteja ordenada,
ele é simples e facil de se implementar mas não é muito eficiente para ordenar vetores grandes.

<br/><br/>

Passo a passo do algoritmo:
<br/>
  

1. Em cada iteração encontre o menor elemento do vetor nao ordenado.
2. O menor elemento é colocado na primeira posição do vetor ordenado.
3. Em seguida o menor elemento é colocado na primeira posição do vetor ordenado.
4. Vetor desordenado fica com um elemento a menos.
5. As etapas 2 a 4 são repetidas sucessivamentes até que o vetor esteja totalmente ordenado.

<br/>

**Exemplo de código em C**

```c

  

void selection_sort(int lista[], int TAM){

    for (int i = 0; i < (TAM-1); i++){

        int min = i;

        for (int j = (i+1); j < TAM; j++){

            if(lista[j] < lista[min])

            min = j;

        }

        if (i != min){

            int aux = lista[i];

            lista[i] = lista[min];

            lista[min] = aux;

        }

    }

}

```

  

### **3. Insertion Sort**

O insertion sort você divide  o vetor em duas partes, uma ordenada e outra desordenada, e a cada iteração ele remove um elemento da parte desordenada e o insere na parte ordenada.
    como voce estivesse ordenando cartas de baralho na mão.

Passo a passo do algoritmo:

**Exemplo de código em C**
<br/>
  

Passo a passo do algoritmo:

<br/>

```c

void insertionSort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
 


# NÂO TERMINEI AINDA, CONTINUAREI EM BREVE...